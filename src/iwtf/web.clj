
;; ================================================================
;; 
;; ATTENTION: DO NOT EDIT THIS FILE DIRECTLY. 
;;
;;            Edit ../../org/iwtf.org instead. The content of this 
;;            source code file is generated from iwtf.org.
;;
;; ================================================================









;; The only reason to look at this generated code directly is if
;; you're curious about the output of the org literate workflow.



































;; You have been warned.
(ns iwtf.web
  (:require [seesaw.core :as ui]
            [seesaw.swingx :as ux]
            [seesaw.font :as font]
            [seesaw.mig :as mig]
            [clj-time.core :as time]
            [clj-webdriver.core :as wd])  
  (:use iwtf.config
        iwtf.web-common
        iwtf.web-element-shopper
        iwtf.locators
        clojure.test))
(defn contains-any [s v]
  (if (empty? v) false
      (or (.contains s (first v))
          (contains-any s (rest v)))))
(defn show-table [title column-names rows]
   (let [t1 (ux/table-x :model [:columns column-names
                                :rows    rows]
                        :show-horizontal-lines? true
                        :show-vertical-lines?   false
                        :fills-viewport-height? true)
         t2 (doto t1 (.setHorizontalScrollEnabled true))
         i  [[(ui/scrollable t2) "grow"]]
         d  (ui/dialog :title title
                       :content (mig/mig-panel :items i :constraints ["fill"]))]
     (-> d ui/pack! (ui/move! :to [0,0]) ui/show!)))
(defn- get-stack
  "requires that `o' be throwable. returns a collection of maps. each
  map is an entry in the stack trace. entries that are from the
  following are skipped: swank, java, clojure. entries that have no
  source file are also skipped. each map has a key-value pair for the
  following: file, line, namespace, method."
  [o]
  (->> (.getStackTrace o)
       (map (fn [e]
              (let [c (map #(.toString %) (.split (.getClassName e) "[$]"))]
                {:File      (.getFileName   e)
                 :Line      (.getLineNumber e)
                 :Namespace (first  c)
                 :Method    (second c)})))
       (remove #(contains-any (:Namespace %) ["swank." "java." "clojure."]))
       (remove #(contains-any (:File      %) ["NO_SOURCE_FILE"]))))

(defn get-relevant-source [file line namespace method]
  (format "\nAt %s/%s (%s:%s)\n\n%s%s\n"
          namespace method
          (.replace file "/home/mint/workshop/iwtf/" "")
          line
          (with-open [rdr (clojure.java.io/reader file)]
            (loop [lines (line-seq rdr)
                   result ""
                   n 0]
              (let [next (try (first lines) (catch Exception e false))
                    remainder (if next (rest lines) false)]
                (cond
                 (and next (< n line)) (let [new-result (if (.startsWith next "(def")
                                                          (str next "\n")
                                                          (str result next "\n"))]
                                         (recur remainder new-result (inc n)))
                 lines result
                 (> n line) :no-such-line))))
          "________________________________________________________________________________"))

(defn get-source [m]
  (let [root "/home/mint/workshop/iwtf/"
        path (if (.startsWith (:Namespace m) "iwtf.test")
               "test/iwtf/"
               "src/iwtf/")
        full (str root path (:File m))]
    (get-relevant-source full
                         (:Line m)
                         (:Namespace m)
                         (:Method m))))

(def code-font
  (font/font :name (if (some #(= % "Consolas") (font/font-families))
                     "Consolas" "Monospaced")))
(def background "#002b36")
(def foreground "#839496")

(defn show-string
  [title content]
  (let [cont (ui/scrollable (ui/text :text content
                                     :multi-line? true
                                     :background background
                                     :foreground foreground
                                     :font code-font))
        items [[cont "span, grow"]]        
        dlg (ui/dialog :title title
                       :content (mig/mig-panel :items items))]
    (-> dlg ui/pack! (ui/move! :to [0,0]) ui/show!)))

(defn- show-stack-common
  [o f]
  (if (instance? Throwable o)
    (f (get-stack o))
    (ui/alert "Sorry. This isn't implemented yet for failures signaled via a false.")))

(defn show-stack2
  "displays the source code for stack trace entries"
  [o]
  (show-stack-common
   o
   #(->> %
         rest ;; getting rid of the wrapper source here
         reverse ;; a more natural order for showing source
         (map get-source)
         (apply str)
         (format "%s... end of expanded trace -- exception occurred here.")
         (show-string "Expanded Stack Trace"))))

(defn show-stack
  "displays a table of stack trace entries."
  [o]
  (show-stack-common
   o
   #(->> %
         (show-table "Stack Trace" [:File :Line :Namespace :Method]))))
(defn- get-field-value [event id]
  (-> event ui/to-root ui/group-by-id id ui/text))
(defn- set-field-value [event id value]
  (let [field (-> event ui/to-root ui/group-by-id id)]
    (ui/text! field value)))
(defn- get-custom-query [event]
  (-> event (get-field-value :custom-query) read-string))
(defn- eval-expression [event browser]
  (let [user (get-field-value event :expression)
        expr (format "(try (do %s) (catch Exception exception exception))" user)
        resu (try (do (require '[clj-webdriver.core :as wd])
                      ((eval (list 'fn '[b] (read-string expr))) browser))
                  (catch Exception exception exception))]
    (set-field-value event :result (pr-str resu))))
(defn- prompt [locator-s locator action-s action value-s value exception browser]
  (let [btn ui/action, wrap "wrap", blank [" " wrap], r ui/return-from-dialog
        wide "span, grow" single "grow"
        m1    (format "Couldn't find  %s  at  %s" locator-s locator)
        m2    (format "Was trying to  %s  with value  [%s]" action-s value)
        stac  (btn :name "View Stack Trace" :mnemonic \s
                   :handler (fn [_] (show-stack exception)))
        sta2  (btn :name "View Expanded Trace" :mnemonic \v
                   :handler (fn [_] (show-stack2 exception)))
        cust  (ui/text :text (pr-str locator) :id :custom-query
                       :font code-font)
        cdef  (btn :name "Catalog Possible Replacements w/ Above Query"
                   :mnemonic \r
                   :handler (fn [e] (make-replacement-locator browser locator-s (get-custom-query e))))
        undo  (btn :name "Undo a redefine (restore the bad definition)"
                   :mnemonic \u
                   :handler (fn [_]
                              (restore-locator-file)
                              (redefine-locator locator-s locator)))
        tipf  (str "<html>In %s, use b to refer to the browser.<br>"
                   "Lib clj-webdriver.core is aliased to wd.<br>"
                   "Edit or delete the example as needed.<br>"
                   "Click the Evaluate button. The result or exception<br>"
                   "will appear in the text area below.</html>")
        exam  "(wd/flash (wd/find-element b {:text \"Register\"}))"
        expr  (ui/scrollable (ui/text :id :expression
                                      :tip (format tipf "this area")
                                      :text exam
                                      :multi-line? true
                                      :font code-font))
        evex  (btn :name "Evaluate Expression" :mnemonic \e
                   :tip (format tipf "the area above")
                   :handler (fn [e] (eval-expression e browser)))
        resu  (ui/scrollable (ui/text :id :result
                                      :tip "This is the result or exception from evaluating the expression above."
                                      :multi-line? true
                                      :font code-font))
        retry (btn :name "Yes, retry"     :mnemonic \y :handler #(r % :retry))
        abort (btn :name "Abort!"         :mnemonic \a :handler #(r % :abort))
        fstep (btn :name "Fail Step"      :mnemonic \s :handler #(r % :fail-step))
        ftest (btn :name "Fail Test"      :mnemonic \t :handler #(r % :fail-test))
        fnspa (btn :name "Fail Namespace" :mnemonic \n :handler #(r % :fail-ns))
        items [[m1 wide]
               [m2 wide] blank
               [stac single][sta2 wide] blank
               [cust wide]
               [cdef single] [undo wide] blank
               [expr "span, grow, hmin 100"] 
               [evex wide]
               [resu "span, grow, hmin 60"] blank
               ["Should I try this test step again?" wide]]
        dlg (ui/dialog :title "Oops"
                       :content (mig/mig-panel :items items) 
                       :options [retry fstep ftest fnspa abort])]
    (-> dlg ui/pack! (ui/move! :to [0,0]) ui/show!)))
;;(do (require 'clj-webdriver.core) (binding [*ns* (the-ns 'clj-webdriver.core)] (eval 'flash)))
(defn- forgiving-find
  [a timeout-s]
  (let [o (wd/find-element *browser* a)]
    (if (no-match o)
      (let [deadline (-> timeout-s time/secs time/from-now)]
        (loop [p (wd/find-element *browser* a)]
          (if (no-match p)
            (if (time/after? (time/now) deadline)
              webdriver-nil
              (recur (wd/find-element *browser* a)))
            p)))
      o)))
(def mode (atom :run))

(defn set-mode [new-mode]
  (swap! mode (fn [old new] new) new-mode))
(defmacro lt
  "like clojure's let form but each binding and the return form might
  be skipped if the mode dictates. this assumes the mode goes from
  :run to something else up to once inside the eventual let and
  doesn't switch back until after we exit the let."
  ([bindings form]
     (loop [b2 []
            bs bindings]
       (if (empty? bs)
         `(let ~b2 (if (= :run (deref mode)) ~form nil))
         (recur (conj b2 (nth bs 0) `(if (= :run (deref mode)) ~(nth bs 1) nil))
                (drop 2 bs)))))
  ([bindings]
     (loop [b2 []
            bs bindings]
       (if (empty? bs)
         `(let ~b2)
         (recur (conj b2 (nth bs 0) `(if (= :run (deref mode)) ~(nth bs 1) nil))
                (drop 2 bs))))))
(defn fixture-test
  "skips the current test if indicated by mode. restores mode if only skipping one test."
  [f]
  (let [m (deref mode)]
    (condp = m
      :run       (do (f) (if (= :skip-test (deref mode)) (set-mode :run)))
      :skip-test (do (println "didn't expect :skip-test! restoring to :run") (set-mode :run) (f))
      :skip-ns   (println "skipped test because of :skip-ns")
      :abort     (println "skipped test because of :abort"))))
(defn fixture-ns
  "skips the current ns if indicated by mode. restores mode if only skipping one namespace."
  [f]
  (let [m (deref mode)]
    (condp = m
      :run       (do (f) (if (= :skip-ns (deref mode)) (set-mode :run)))
      :skip-test (do (println "didn't expect :skip-test! restoring to :run") (set-mode :run) (f))
      :skip-ns   (do (println "didn't expect :skip-ns! restoring to :run")   (set-mode :run) (f))
      :abort     (println "skipped namespace because of :abort"))))  
(defn web-
  [locator-s locator action-s action value-s value timeout-secs]
  (if (nil? value)
    :skip
    (let [fstr "Could not find element %s at %s and user chose to fail %s"
          fail (fn [response new-mode]
                 (set-mode new-mode)
                 (->> (format fstr locator-s locator response)
                      (is false)))]
      (loop [finding (forgiving-find locator timeout-secs)]
        (if (no-match finding)
          (case (prompt locator-s locator action-s action value-s value (Exception.) *browser*)
            :retry     (recur (forgiving-find (eval (read-string (str "iwtf.locators/" locator-s))) timeout-secs))
            :fail-step (fail "this step" :run)
            :fail-test (fail "this test" :skip-test)
            :fail-ns   (fail "this namespace" :skip-ns)
            :abort     (fail "all remaining tests (abort)" :abort))
          ;; at this point we found the element
          (if (= value :insignificant)
            (apply action [finding])
            (apply action [finding value])))))))
(defmacro web

  ([locator action]
     ;;`(web- '~locator ~locator '~action ~action :insignificant :insignificant)
     `(web ~locator ~action :insignificant))

  ([locator action value]
     ;;`(web- '~locator ~locator '~action ~action '~value ~value)
     `(web ~locator ~action ~value fudge-secs))

  ([locator action value timeout-secs]
     `(web- '~locator ~locator '~action ~action '~value ~value ~timeout-secs)))
(defmacro enter
  "enters text in the specified field. does not clear the field first."
  [attributes value]
  `(web ~attributes wd/input-text ~value))
(defmacro clear
  "clears a field"
  [attributes]
  `(web ~attributes wd/clear))
(defmacro pickt
  "finds a drop-down list ddl by 'attributes' and then picks the option matching the text"
  [attributes text]
  `(web ~attributes wd/select-by-text ~text))
(defmacro pickv
  "finds a drop-down list ddl by 'attributes' and then picks the option matching the value"
  [attributes value]
  `(web ~attributes wd/select-by-value ~value))
(defmacro selected?
  "returns whether the element is selected"
  [attributes]
  `(web ~attributes wd/selected?))
(defmacro check
  "leaves the specified checkbox in the state 'leave-checked'"
  [attributes leave-checked]
  `(do (web ~attributes wd/select)
       (if (not ~leave-checked)
         (web ~attributes wd/toggle))))
(defmacro click [attributes] `(web ~attributes wd/click))
(defmacro text [attributes] `(web ~attributes wd/text))
(defmacro value [attributes] `(web ~attributes wd/value))
(defmacro get-class [attributes]
  `(web ~attributes (fn [e#] (wd/attribute e# "class"))))
 ;; this has to be public because of the macro that calls it.
(defn assert-visible?
  "throws an exception if element is visible/not-visible as expected. returns true otherwise."
  [element expected]
  (if (= expected (wd/visible? element))
    true
    (-> (format "expected %s to be %s visible but it was otherwise" element expected)
        Exception. throw)))

(defmacro wait-until-visible?
  [attributes expected timeout-secs]
  `(web ~attributes assert-visible? ~expected ~timeout-secs))
(defn wait-for-condition
  "waits for f to return true or for timeout-secs to expire, polling
   every poll-msecs. returns true if f became true before timeout-secs
   expired. returns false if the timeout-secs expired."
  [f timeout-secs poll-msecs]
  (-> (loop [t 0]
        (cond (f) true
              (> (/ t 1000) timeout-secs) false
              :else (do (. Thread (sleep poll-msecs))
                        (recur (+ t poll-msecs)))))
      is))
(defn present?
  "returns true if element is present"
  [locator]
  (->> locator
       (wd/find-element *browser*)
       wd/present?))
(defn exit-iframe-select-root
  "moves focus to the outermost root document. use this if you're in
  an iframe (or if you think you might be) such as the fulfillment
  iframe in ma sw"
  []
  (wd/switch-to-default *browser*))
